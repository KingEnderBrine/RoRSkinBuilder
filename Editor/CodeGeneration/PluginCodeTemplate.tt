<#@ template language="C#" Inherits="PluginCodeTemplateBase" linePragmas="false" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="RoRSkinBuilder.Data" #>
<#@ import namespace="UnityEngine.Rendering" #>
using BepInEx;
using BepInEx.Logging;
using RoR2;
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Linq;
using UnityEngine;
using System.Security.Permissions;
using MonoMod.RuntimeDetour.HookGen;
using RoR2.ContentManagement;
using UnityEngine.AddressableAssets;
using RoR2.Projectile;


#pragma warning disable CS0618 // Type or member is obsolete
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
#pragma warning restore CS0618 // Type or member is obsolete
namespace <#= AssetsInfo.uccModName #>
{
<# foreach (var dependency in DistinctDependencies) { #>
    [BepInDependency("<#= dependency.Key #>", BepInDependency.DependencyFlags.<#= Enum.GetName(typeof(DependencyType), dependency.Value) #>)]
<# } #>
    
    [BepInPlugin("com.<#= SkinModInfo.author.StripSpaces() #>.<#= AssetsInfo.uccModName #>","<#= SkinModInfo.modName #>","<#= SkinModInfo.version #>")]
    public partial class <#= AssetsInfo.uccModName #>Plugin : BaseUnityPlugin
    {
        internal static <#= AssetsInfo.uccModName #>Plugin Instance { get; private set; }
        internal static ManualLogSource InstanceLogger => Instance?.Logger;
        
        private static AssetBundle assetBundle;
<# if (AssetsInfo.materialsWithRoRShader.Count != 0) { #>
        private static readonly List<Material> materialsWithRoRShader = new List<Material>();
<# } #>
        private void Start()
        {
            Instance = this;

            BeforeStart();

            using (var assetStream = Assembly.GetExecutingAssembly().GetManifestResourceStream("<#= AssetsInfo.uccModName #>.<#= AssetsInfo.assetBundleName #>"))
            {
                assetBundle = AssetBundle.LoadFromStream(assetStream);
            }

            BodyCatalog.availability.CallWhenAvailable(BodyCatalogInit);
            HookEndpointManager.Add(typeof(Language).GetMethod(nameof(Language.LoadStrings)), (Action<Action<Language>, Language>)LanguageLoadStrings);

<# if (AssetsInfo.materialsWithRoRShader.Count != 0) { #>
            ReplaceShaders();

<# } #>
            AfterStart();
        }

        partial void BeforeStart();
        partial void AfterStart();
        static partial void BeforeBodyCatalogInit();
        static partial void AfterBodyCatalogInit();

<# if (AssetsInfo.materialsWithRoRShader.Count != 0) { #>
        private static void ReplaceShaders()
        {
<# foreach (var row in AssetsInfo.materialsWithRoRShader) { #>
            LoadMaterialsWithReplacedShader(@"<#= row.Key #>"
<# foreach (var material in row.Value) { #>
                ,@"<#= AssetsInfo.materialPaths[material] #>"<# } #>);
<# } #>
        }

        private static void LoadMaterialsWithReplacedShader(string shaderPath, params string[] materialPaths)
        {
            var shader = Addressables.LoadAssetAsync<Shader>(shaderPath).WaitForCompletion();
            foreach (var materialPath in materialPaths)
            {
                var material = assetBundle.LoadAsset<Material>(materialPath);
                material.shader = shader;
                materialsWithRoRShader.Add(material);
            }
        }
<# } #>

        private static void LanguageLoadStrings(Action<Language> orig, Language self)
        {
            orig(self);

<# var tokensByLanguage = new Dictionary<string, Dictionary<string, string>>();
var defaultTokens = new Dictionary<string, string>();

foreach (var skin in ReorderedSkins) {
    if (skin.nameTokenLocalizations.Count == 0) {
        continue;
    }
    var nameToken = skin.CreateNameToken(SkinModInfo.author);
    defaultTokens[nameToken] = (skin.nameTokenLocalizations.FirstOrDefault(el => el.language.ToLower() == "en") ?? skin.nameTokenLocalizations.First()).value; 
    
    foreach (var localization in skin.nameTokenLocalizations) {
        if (defaultTokens[nameToken] == localization.value) {
            continue;
        }
        var language = localization.language.ToLower();
        if (!tokensByLanguage.TryGetValue(language, out var tokens)) {
            tokensByLanguage[language] = tokens = new Dictionary<string, string>();
        }
        tokens[nameToken] = localization.value;
    } 
} #>
<# foreach (var row in defaultTokens) { #>
            self.SetStringByToken("<#= row.Key #>", "<#= row.Value.Escape() #>");
<# } #>
<# if (tokensByLanguage.Count > 0) { #>

            switch(self.name.ToLower())
            {
<#     foreach (var row in tokensByLanguage) { #>
                case "<#= row.Key #>":
<#         foreach (var value in row.Value) { #>
                    self.SetStringByToken("<#= value.Key #>", "<#= value.Value.Escape() #>");
<#         } #>
                    break;
<#     } #>
            }
<# } #>
        }

        private static void BodyCatalogInit()
        {
            BeforeBodyCatalogInit();

<# foreach (var skin in ReorderedSkins) { #>
            Add<#= skin.bodyName.ToUpperCamelCase() #><#= skin.name.ToUpperCamelCase() #>Skin();
<# } #>

            AfterBodyCatalogInit();
        }
<# foreach (var skin in ReorderedSkins) { #>

        static partial void <#= skin.bodyName.ToUpperCamelCase() #><#= skin.name.ToUpperCamelCase() #>SkinAdded(SkinDef skinDef, GameObject bodyPrefab);

        private static void Add<#= skin.bodyName.ToUpperCamelCase() #><#= skin.name.ToUpperCamelCase() #>Skin()
        {
<# if (!string.IsNullOrWhiteSpace(skin.modDependency.value) && skin.modDependency.type == DependencyType.SoftDependency) { #>
            if (!BepInEx.Bootstrap.Chainloader.PluginInfos.ContainsKey("<#= skin.modDependency.value #>"))
            {
                return;
            }
<# } #>
<# if (skin.config.generateEnableConfig) { #>
            if (!Instance.Config.Bind("<#= skin.name.ToUpperCamelCase() #>", "Enabled", <#= skin.config.enableConfigDefaultValue.ToLiteral() #>).Value)
            {
                return;
            }
<# } #>
            var bodyName = "<#= skin.bodyName #>";
            var skinName = "<#= skin.name #>";
            try
            {
                var bodyPrefab = BodyCatalog.FindBodyPrefab(bodyName);
                if (!bodyPrefab)
                {
                    InstanceLogger.LogWarning($"Failed to add \"{skinName}\" skin because \"{bodyName}\" doesn't exist");
                    return;
                }

                var modelLocator = bodyPrefab.GetComponent<ModelLocator>();
                if (!modelLocator)
                {
                    InstanceLogger.LogWarning($"Failed to add \"{skinName}\" skin to \"{bodyName}\" because it doesn't have \"ModelLocator\" component");
                    return;
                }

                var mdl = modelLocator.modelTransform.gameObject;
                var skinController = mdl ? mdl.GetComponent<ModelSkinController>() : null;
                if (!skinController)
                {
                    InstanceLogger.LogWarning($"Failed to add \"{skinName}\" skin to \"{bodyName}\" because it doesn't have \"ModelSkinController\" component");
                    return;
                }

                var renderers = mdl.GetComponentsInChildren<Renderer>(true);
                var lights = mdl.GetComponentsInChildren<Light>(true);

                var skin = ScriptableObject.CreateInstance<SkinDef>();
                var skinParams = ScriptableObject.CreateInstance<SkinDefParams>();
                skin.skinDefParams = skinParams;

                TryCatchThrow("Icon", () =>
                {
<# if (!skin.icon.createFromColors) {
        if (skin.icon.sprite) { #>
                    skin.icon = assetBundle.LoadAsset<Sprite>(@"<#= AssetsInfo.iconPaths[skin.icon.sprite] #>");
<#      } else { #>
                    skin.icon = null;
<#      } 
    } else { #>
                    skin.icon = assetBundle.LoadAsset<Sprite>(@"<#= AssetsInfo.iconFromColorPaths[skin.icon.colors] #>");
<# } #>
                });
                skin.name = skinName;
                skin.nameToken = "<#= skin.CreateNameToken(SkinModInfo.author) #>";
                skin.rootObject = mdl;
                TryCatchThrow("Base Skins", () =>
                {
<# if (skin.baseSkins.Count == 0) { #>
                    skin.baseSkins = Array.Empty<SkinDef>();
<# } else { #>
                    skin.baseSkins = new SkinDef[] 
                    { 
<# for (var i = 0; i < skin.baseSkins.Count; i++) {
    var reference = skin.baseSkins[i];
    if (reference.accessType == AccessType.ByIndex) { #>
                        ThrowIfOutOfBounds(<#= i #>, "Index <#= reference.index #> is out of bounds of skins array", skinController.skins, <#= reference.index #>),
<# } else { #>
                        ThrowIfNull(<#= i #>, "There is no skin with the name \"<#= reference.name #>\"", skinController.skins.FirstOrDefault(s => s.Name == "<#= reference.name #>")),
<# } 
} #>
                    };
<# } #>
                });
                TryCatchThrow("Unlockable Name", () =>
                {
<# if (string.IsNullOrWhiteSpace(skin.unlockableName)) { #>
                    skin.unlockableDef = null;
<# } else { #>
                    skin.unlockableDef = ContentManager.unlockableDefs.FirstOrDefault(def => def.cachedName == "<#= skin.unlockableName #>");
<# } #>
                });
                TryCatchThrow("Game Object Activations", () =>
                {
<# if (skin.gameObjectActivations.Count == 0) { #>
                    skinParams.gameObjectActivations = Array.Empty<SkinDefParams.GameObjectActivation>();
<# } else { #>
                    skinParams.gameObjectActivations = new SkinDefParams.GameObjectActivation[]
                    {
<# for (var i = 0; i < skin.gameObjectActivations.Count; i++) {
    var activation = skin.gameObjectActivations[i]; #>
                        new SkinDefParams.GameObjectActivation
                        {
<# if (activation.accessType == GameObjectActivationAccessType.ByRendererName) { #>
                            gameObject = ThrowIfNull(<#= i #>, "There is no renderer with the name \"<#= activation.rendererName #>\"", renderers.FirstOrDefault(r => r.name == "<#= activation.rendererName #>")).gameObject,
<# } else if (activation.accessType == GameObjectActivationAccessType.ByPath) { #>
                            gameObject = ThrowIfNull(<#= i #>, "There is no renderer at path \"<#= activation.path #>\"", mdl.transform.Find("<#= activation.path #>")).gameObject,
<# } #>
<# if (activation.spawnPrefabOnModelObject) { #>
                            shouldActivate = false,
                            spawnPrefabOnModelObject = true,
                            localPosition = <#= activation.localPosition.ToNewString() #>,
                            localRotation = <#= activation.localRotation.ToNewString() #>,
                            localScale = <#= activation.localScale.ToNewString() #>,
<#      if (activation.useAddressablesKey) { #>
                            prefab = Addressables.LoadAssetAsync<GameObject>(@"<#= activation.prefabKey #>").WaitForCompletion()
<#      } else { #>
                            prefab = assetBundle.LoadAsset<GameObject>(@"<#= AssetsInfo.uniqueGameObjectActivations[activation.prefab] #>")
<#      } #>
<# } else { #>
                            shouldActivate = <#= activation.shouldActivate.ToLiteral() #>,
                            spawnPrefabOnModelObject = false,
<# } #>
                        },
<# } #>
                    };
<# } #>
                });
                TryCatchThrow("Renderer Infos", () =>
                {
<# if (skin.rendererInfos.Count == 0) { #>
                    skinParams.rendererInfos = Array.Empty<CharacterModel.RendererInfo>();
<# } else { #>
                    skinParams.rendererInfos = new CharacterModel.RendererInfo[]
                    {
<# for (var i = 0; i < skin.rendererInfos.Count; i++) {
    var rendererInfo = skin.rendererInfos[i]; #>
                        new CharacterModel.RendererInfo
                        {
<# if (rendererInfo.defaultMaterial == null) { #>
                            defaultMaterial = null,
<# } else { #>
                            defaultMaterial = assetBundle.LoadAsset<Material>(@"<#= AssetsInfo.materialPaths[rendererInfo.defaultMaterial] #>"),
<# } #>
                            defaultShadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.<#= Enum.GetName(typeof(ShadowCastingMode), rendererInfo.defaultShadowCastingMode) #>,
                            ignoreOverlays = <#= rendererInfo.ignoreOverlays.ToLiteral() #>,
<# if (rendererInfo.rendererReference.accessType == ComponentAccessType.ByName) { #>
                            renderer = ThrowIfNull(<#= i #>, "There is no renderer with the name \"<#= rendererInfo.rendererReference.name #>\"", renderers.FirstOrDefault(r => r.name == "<#= rendererInfo.rendererReference.name #>")),
<# } else if (rendererInfo.rendererReference.accessType == ComponentAccessType.ByPath) { #>
                            renderer = ThrowIfNull(<#= i #>, "There is no renderer at path \"<#= rendererInfo.rendererReference.path #>\"", mdl.transform.Find("<#= rendererInfo.rendererReference.path #>")).GetComponent<Renderer>(),
<# } #>
                        },
<# } #>
                    };
<# } #>
                });
                TryCatchThrow("Mesh Replacements", () =>
                {
<# if (skin.meshReplacements.Count == 0) { #>
                    skinParams.meshReplacements = Array.Empty<SkinDefParams.MeshReplacement>();
<# } else { #>
                    skinParams.meshReplacements = new SkinDefParams.MeshReplacement[]
                    {
<# for (var i = 0; i < skin.meshReplacements.Count; i++) {
    var replacement = skin.meshReplacements[i]; #>
                        new SkinDefParams.MeshReplacement
                        {
<# if (replacement.mesh == null) { #>
                            mesh = null,
<# } else { #>
                            mesh = assetBundle.LoadAsset<Mesh>(@"<#= AssetsInfo.meshPaths[replacement.mesh] #>"),
<# } 
if (replacement.rendererReference.accessType == ComponentAccessType.ByName) { #>
                            renderer = ThrowIfNull(<#= i #>, "There is no renderer with the name \"<#= replacement.rendererReference.name #>\"", renderers.FirstOrDefault(r => r.name == "<#= replacement.rendererReference.name #>")),
<# } else if (replacement.rendererReference.accessType == ComponentAccessType.ByPath) { #>
                            renderer = ThrowIfNull(<#= i #>, "There is no renderer at path \"<#= replacement.rendererReference.path #>\"", mdl.transform.Find("<#= replacement.rendererReference.path #>")).GetComponent<Renderer>(),
<# } #>
                        },
<# } #>
                    };
<# } #>
                });
                TryCatchThrow("Light Infos", () =>
                {
<# if (skin.meshReplacements.Count == 0) { #>
                    skinParams.lightReplacements = Array.Empty<CharacterModel.LightInfo>();
<# } else { #>
                    skinParams.lightReplacements = new CharacterModel.LightInfo[]
                    {
<# for (var i = 0; i < skin.lightReplacements.Count; i++) {
    var replacement = skin.lightReplacements[i]; #>
                        new CharacterModel.LightInfo
                        {
                            defaultColor = <#= replacement.defaultColor.ToNewString() #>,
<# if (replacement.lightReference.accessType == ComponentAccessType.ByName) { #>
                            light = ThrowIfNull(<#= i #>, "There is no light with the name \"<#= replacement.lightReference.name #>\"", lights.FirstOrDefault(l => l.name == "<#= replacement.lightReference.name #>")),
<# } else if (replacement.lightReference.accessType == ComponentAccessType.ByPath) { #>
                            light = ThrowIfNull(<#= i #>, "There is no light at path \"<#= replacement.lightReference.path #>\"", mdl.transform.Find("<#= replacement.lightReference.path #>")).GetComponent<Light>(),
<# } #>
                        },
<# } #>
                    };
<# } #>
                });
                TryCatchThrow("Minion Skin Replacements", () =>
                {
<# if (skin.minionSkinReplacements.Count == 0) { #>
                    skinParams.minionSkinReplacements = Array.Empty<SkinDefParams.MinionSkinReplacement>();
<# } else { #>
                    skinParams.minionSkinReplacements = new SkinDefParams.MinionSkinReplacement[]
                    {
<# for (var i = 0; i < skin.minionSkinReplacements.Count; i++) {
    var replacement = skin.minionSkinReplacements[i];
    if (!replacement.findSkinByReference && replacement.skin == null) {
        continue;
    } #>
                        new SkinDefParams.MinionSkinReplacement
                        {
                            minionBodyPrefab = BodyCatalog.FindBodyPrefab(@"<#= replacement.bodyName #>"),
<# if (replacement.findSkinByReference) { 
    if (replacement.reference.accessType == AccessType.ByIndex) { #>
                            minionSkin = ThrowIfOutOfBounds(<#= i #>, "Index <#= replacement.reference.index #> is out of bounds of skins array for body \"<#= replacement.bodyName #>\"", SkinCatalog.FindSkinsForBody(ThrowIfEquals(<#= i #>, "Body \"<#= replacement.bodyName #>\" doesn't exist", BodyCatalog.FindBodyIndex(@"<#= replacement.bodyName #>"), BodyIndex.None)), <#= replacement.reference.index #>),
<# } else { #>
                            minionSkin = ThrowIfNull(<#= i #>, "There is no skin with the name \"<#= replacement.reference.name #>\" for body \"<#= replacement.bodyName #>\"", SkinCatalog.FindSkinsForBody(ThrowIfEquals(<#= i #>, "Body \"<#= replacement.bodyName #>\" doesn't exist", BodyCatalog.FindBodyIndex(@"<#= replacement.bodyName #>"), BodyIndex.None)).FirstOrDefault(s => s.name == @"<#= replacement.reference.name #>")),
    <# }
} else { #>
                            minionSkin = ThrowIfNull(<#= i #>, "There is no skin with the name \"<#= replacement.skin.name #>\" for body \"<#= replacement.bodyName #>\"", SkinCatalog.FindSkinsForBody(ThrowIfEquals(<#= i #>, "Body \"<#= replacement.bodyName #>\" doesn't exist", BodyCatalog.FindBodyIndex(@"<#= replacement.bodyName #>"), BodyIndex.None)).FirstOrDefault(s => s.name == @"<#= replacement.skin.name #>")),
<# } #>
                        },
<# } #>
                    };
<# } #>
                });
                TryCatchThrow("Projectile Ghost Replacements", () =>
                {
<# foreach (var path in AssetsInfo.uniqueProjectileGhostsBySkin[skin]) { #>
                    TryAddComponent<ProjectileGhostController>(assetBundle.LoadAsset<GameObject>(@"<#= path #>"));
<# } #>
<# if (skin.projectileGhostReplacements.Count == 0) { #>
                    skinParams.projectileGhostReplacements = Array.Empty<SkinDefParams.ProjectileGhostReplacement>();
<# } else { #>
                    skinParams.projectileGhostReplacements = new SkinDefParams.ProjectileGhostReplacement[]
                    {
<# foreach (var replacement in skin.projectileGhostReplacements) { #>
                        new SkinDefParams.ProjectileGhostReplacement
                        {
                            projectilePrefab = Addressables.LoadAssetAsync<GameObject>(@"<#= replacement.projectilePath #>").WaitForCompletion(),
<# if (replacement.useAddressablesPath) { #>
                            projectileGhostReplacementPrefab = Addressables.LoadAssetAsync<GameObject>(@"<#= replacement.projectileGhostPath #>").WaitForCompletion(),
<# } else { #>
                            projectileGhostReplacementPrefab = assetBundle.LoadAsset<GameObject>(@"<#= AssetsInfo.uniqueProjectileGhosts[replacement.projectileGhost] #>"),
<# } #>
                        },
<# } #>
                    };
<# } #>
                });

                Array.Resize(ref skinController.skins, skinController.skins.Length + 1);
                skinController.skins[skinController.skins.Length - 1] = skin;

                <#= skin.bodyName.ToUpperCamelCase() #><#= skin.name.ToUpperCamelCase() #>SkinAdded(skin, bodyPrefab);
            }
            catch (FieldException e)
            {
                if (e.InnerException is ElementException ie)
                {
					InstanceLogger.LogWarning($"Failed to add \"{skinName}\" skin to \"{bodyName}\"");
					InstanceLogger.LogWarning($"Field causing issue: {e.Message}, element: {ie.Index}");
					InstanceLogger.LogWarning(ie.Message);
					InstanceLogger.LogError(e.InnerException);
                }
                else
                {
					InstanceLogger.LogWarning($"Failed to add \"{skinName}\" skin to \"{bodyName}\"");
					InstanceLogger.LogWarning($"Field causing issue: {e.Message}");
					InstanceLogger.LogError(e.InnerException);
                }
            }
            catch (Exception e)
            {
                InstanceLogger.LogWarning($"Failed to add \"{skinName}\" skin to \"{bodyName}\"");
                InstanceLogger.LogError(e);
            }
        }
<# } #>

        private static T ThrowIfEquals<T>(int index, string message, T value, T expected) where T: Enum
        {
            if (value.Equals(expected))
            {
                throw new ElementException(index, message);
            }

            return value;
        }
        
        private static T ThrowIfOutOfBounds<T>(int index, string message, T[] array, int elementIndex) where T: class
        {
            if (array is null || array.Length <= elementIndex)
            {
                throw new ElementException(index, message);
            }

            return array[elementIndex];
        }

        private static T ThrowIfNull<T>(int index, string message, T value) where T: class
        {
            if (value is null)
            {
                throw new ElementException(index, message);
            }

            return value;
        }

        private static void TryCatchThrow(string message, Action action)
        {
            try
            {
                action?.Invoke();
            }
            catch (Exception e)
            {
                throw new FieldException(message, e);
            }
        }
        
        private static void TryAddComponent<T>(GameObject obj) where T : Component
        {
            if (obj && !obj.GetComponent<T>())
            {
                obj.AddComponent<T>();
            }
        }

        private class FieldException : Exception
        {
            public FieldException(string message, Exception innerException) : base(message, innerException) { }
        }

        private class ElementException : Exception
        {
            public int Index { get; }
            public ElementException(int index, string message) : base(message)
            {
                Index = index;
            }
        }
    }
}